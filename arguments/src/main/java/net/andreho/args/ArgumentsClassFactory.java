package net.andreho.args;

import net.andreho.haxxor.Haxxor;
import net.andreho.haxxor.api.HxField;
import net.andreho.haxxor.api.HxMethod;
import net.andreho.haxxor.api.HxType;
import net.andreho.haxxor.cgen.HxExtendedCodeStream;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Comparator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.andreho.haxxor.utils.NamingUtils.toDescriptor;
import static net.andreho.haxxor.utils.NamingUtils.toInternalClassname;

/**
 * <br/>Created by a.hofmann on 15.07.2017 at 06:03.
 */
final class ArgumentsClassFactory {

  private static final String OUTER_CLASS_NAME = ArgumentsClassFactory.class.getName();
  private static final ConcurrentMap<String, String> SIGNATURE_MAPPING = new ConcurrentHashMap<>();
  private static final AtomicLong ID_SOURCE = new AtomicLong();
  private static final String FIELDS_PREFIX = "arg_";

  static String createArgumentsClassFor(final Class<?>... signature) {
    if (signature == null || signature.length == 0) {
      throw new IllegalArgumentException("Empty signature isn't supported");
    }
    final ArgumentsType[] layoutTypes = new ArgumentsType[signature.length];
    for (int i = 0; i < layoutTypes.length; i++) {
      layoutTypes[i] = ArgumentsType.fromClass(signature[i]);
    }

    Arrays.sort(layoutTypes, Comparator.reverseOrder());
    return createArgumentsClassFor(layoutTypes);
  }

  static String createArgumentsClassFor(final String signature) {
    if (signature == null || signature.length() == 0) {
      throw new IllegalArgumentException("Empty signature isn't supported");
    }
    final ArgumentsType[] layoutTypes = new ArgumentsType[signature.length()];
    for (int i = 0; i < layoutTypes.length; i++) {
      layoutTypes[i] = ArgumentsType.fromCharCode(signature.charAt(i));
    }

    Arrays.sort(layoutTypes, Comparator.reverseOrder());
    return createArgumentsClassFor(layoutTypes);
  }

  private static String createArgumentsClassFor(final ArgumentsType[] layout) {
    return createArgumentsClass(
      DynamicClassPathInstaller.INSTALLATION_FOLDER, toLayoutString(layout), layout
    );
  }

  private static String toLayoutString(final ArgumentsType[] layout) {
    return Stream.of(layout)
                 .map(type -> Character.toString(type.getCode()))
                 .collect(Collectors.joining(""));
  }

  private static String createArgumentsClass(
    final Path outputPath,
    final String layoutString,
    final ArgumentsType[] layout) {

    return SIGNATURE_MAPPING.computeIfAbsent(
      layoutString,
      key -> {
        final String className = OUTER_CLASS_NAME + "$" + ID_SOURCE.incrementAndGet();
        final String pathToClass = className.replace('.', '/');
        final byte[] byteCode = generateByteCode(layout, layoutString, className);
        final Path targetFile = outputPath.resolve(pathToClass + ".class").toAbsolutePath();
//        Debugger.trace(byteCode);

        if (!Files.exists(targetFile)) {
          try {
            Files.createDirectories(targetFile.getParent());
            Files.write(targetFile, byteCode);
          } catch (IOException e) {
            throw new IllegalStateException(
              "Unable to store the generated bytecode in the given output location: " + outputPath.toAbsolutePath(),
              e);
          }
        }
        return className;
      }
    );
  }

  private static byte[] generateByteCode(final ArgumentsType[] layout,
                                         final String layoutString,
                                         final String className) {
    final Haxxor haxxor = new Haxxor();
    final HxType type = haxxor.createType(className);
    type.addModifiers(
      HxType.Modifiers.PUBLIC, HxType.Modifiers.SYNTHETIC, HxType.Modifiers.FINAL
    ).setSupertype(AbstractArguments256.class);

    addConstructor(haxxor, type, layoutString);
    addFields(haxxor, layout, type);

    return type.toByteCode();
  }

  private static void addConstructor(final Haxxor haxxor,
                                     final HxType type,
                                     final String layout) {
    HxMethod constructor = haxxor.createConstructor(String.class)
                                 .addModifier(HxMethod.Modifiers.PUBLIC);
    HxExtendedCodeStream stream = constructor.getBody().getFirst().asStream();

    stream
      .LABEL()
      .THIS()
      .ALOAD(1)
      .LDC(layout)
      .LDC(layout.length())
      .INVOKESPECIAL(
        toInternalClassname(AbstractArguments256.class),
        "<init>",
        toDescriptor(Void.TYPE, String.class, String.class, Integer.TYPE)
      )
      .RETURN()
      .LABEL();

    type.addConstructor(constructor);
  }

  private static void addFields(final Haxxor haxxor,
                                final ArgumentsType[] layout,
                                final HxType type) {

    final int digitsCount = Integer.toString(layout.length - 1).length();

    for (int i = 0; i < layout.length; i++) {
      final ArgumentsType argType = layout[i];
      final String fieldName = FIELDS_PREFIX + lpad(Integer.toString(i), digitsCount, '0');
      final HxField field =
        haxxor.createField(argType.getFieldType(), fieldName)
              .addModifiers(HxField.Modifiers.PUBLIC, HxField.Modifiers.SYNTHETIC);

      type.addField(field);
    }
  }

  private static String lpad(final String value,
                             final int length,
                             final char pad) {
    if (length >= value.length()) {
      return value;
    }

    final StringBuilder builder = new StringBuilder();
    for (int i = value.length(); i < length; i++) {
      builder.append(pad);
    }
    return builder.append(value).toString();
  }
}
